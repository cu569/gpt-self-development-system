from flask import Flask, render_template_string, request, jsonify
import concurrent.futures
import threading
import time

app = Flask(__name__)

# ----- 리마/상황판 상태 -----
TOTAL_RIMA = 10    # 100000으로 확장 가능
languages = ['en','zh','ja','vi','es']
success = 0
fail = 0
lock = threading.Lock()
logs = []

# ----- 리마 실행 함수 -----
def rima_job(idx):
    global success, fail, logs
    lang = languages[idx % len(languages)]
    msg = f"[RIMA-{idx}] {lang} 업로드 준비..."
    with lock: logs.append(msg)
    try:
        # 여기에 실제 유튜브 업로드 자동화(또는 시뮬레이션) 코드 삽입
        time.sleep(0.1)
        msg2 = f"[RIMA-{idx}] {lang} 업로드 성공!"
        with lock:
            success += 1
            logs.append(msg2)
    except Exception as e:
        msg2 = f"[RIMA-{idx}] 실패: {str(e)}"
        with lock:
            fail += 1
            logs.append(msg2)

# ----- API/웹서버 -----
@app.route('/')
def index():
    # HTML(상황판/채팅) 직접 렌더링
    html = '''
    <!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <title>리마 상황판/채팅</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
      <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body class="bg-slate-100 min-h-screen">
      <div class="max-w-xl mx-auto p-4">
        <h2 class="text-2xl font-bold mb-4 text-indigo-700">리마 상황판/채팅</h2>
        <div id="status" class="bg-white rounded-xl shadow p-3 mb-3 text-indigo-900"></div>
        <div id="chat" class="bg-slate-50 rounded-xl shadow p-3 mb-2 h-64 overflow-y-auto text-sm"></div>
        <div class="flex gap-2">
          <input id="msg" class="flex-1 border rounded p-2" placeholder="메시지/명령 입력"/>
          <button onclick="sendMsg()" class="bg-indigo-600 text-white px-5 py-2 rounded-lg font-semibold">전송</button>
          <button onclick="runRima()" class="bg-emerald-600 text-white px-4 py-2 rounded-lg font-semibold ml-1">리마 실행</button>
        </div>
      </div>
      <script>
        async function update() {
          let res = await fetch('/status'); let j = await res.json();
          document.getElementById('status').innerHTML =
            `리마: ${j.total}개<br>성공: ${j.success} / 실패: ${j.fail} / 진행률: ${j.progress}`;
          document.getElementById('chat').innerHTML =
            j.logs.slice(-30).map(m=>"<div>"+m+"</div>").join('');
          document.getElementById('chat').scrollTop = 99999;
        }
        async function sendMsg() {
          let m = document.getElementById('msg').value;
          if(!m) return;
          await fetch('/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({'msg': m})});
          document.getElementById('msg').value = '';
          update();
        }
        async function runRima() {
          await fetch('/run', {method:'POST'});
          setTimeout(update, 500);
        }
        setInterval(update, 1200);
        update();
      </script>
    </body>
    </html>
    '''
    return render_template_string(html)

@app.route('/status')
def status():
    global success, fail, logs
    prog = f"{(success+fail)/TOTAL_RIMA*100:.2f}%" if TOTAL_RIMA>0 else "0%"
    return jsonify({'total': TOTAL_RIMA, 'success': success, 'fail': fail, 'progress': prog, 'logs': logs})

@app.route('/chat', methods=['POST'])
def chat():
    global logs
    data = request.json
    logs.append(f"<b>나:</b> {data['msg']}")
    return jsonify({'result':'ok'})

@app.route('/run', methods=['POST'])
def run():
    global success, fail, logs
    # 상태 리셋
    success = 0; fail = 0; logs.clear()
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        executor.map(rima_job, range(1, TOTAL_RIMA+1))
    logs.append("전체 리마 실행 완료!")
    return jsonify({'result':'ok'})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
